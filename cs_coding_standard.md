
# Стандарт кодирования на C# #

За основу взяты следующие стандарты:  
* [MS Framework Design Guidelines](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/index)   
* [NASA C++ Coding Standards and Style Guide](https://ntrs.nasa.gov/search.jsp?R=20080039927)  
* [Linux kernel coding style](https://www.kernel.org/doc/html/v4.10/process/coding-style.html)  
*	[Bill Wagner - Effective C# - Bill Wagner](http://www.thebillwagner.com/Resources)  

В 90% случаев предполагается придерживаться стандарта [MS](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/index). Здесь же будут описаны отличия, от этого стандарта.

## Форматирование кода ##
#### 1. Tab vs Space.  ###
Хотя в VS используются по умолчанию пробелы, все же рекомендую выставлять табы (без замены на пробелы).   

*Мотивация*: Таб представляет собой один символ, при этом он позволяет настроить среду как удобно пользователю, хоть 2а пробела, 4е пробела или даже 8 пробелов.  

#### 2. Фигурные скобки.  ###
Все что может быть ограничено фигурными скобками, должно быть ими ограничено.  

*Мотивация*: Основная мотивация - однородность кода, так его легче воспринимать. Из-за простоты восприятия, снижается вероятность ошибки когда кто-то закомментирует строчку кода после if/while и т.п. и следующая строка станет считаться телом оператора.

*Пример*
```C#
if(Ok) 
    return OkResult;  // Bad

if(Ok) //Good
{
    return OkResult;
}
```

#### 3. Пустая строка между частями кода. ####
Между двумя "смежными методами" (методоп и полем, методом и свойством, и т.д.) должно быть ДВЕ пустые строки, В то время как между строками кода, там где это нужно, не должно быть более одной пустой строки.

*Мотивация*: Такое расставление пустых строк в коде повышает уровень его воспрятия.

#### 4. Регионы. ####
**НЕ**использовать регионы.  
*Мотивация*: В регионах может прятаться много кода.


## Конструирование типов ##
#### 1. Уровни доступа классов. ####
Все классы, доступ к которым из вне не предполагается, должны быть помечены как internal. Также должны быть помечены все их поля/методы/свойства, которые, в обычной ситуации, были бы помечены как public.  

*Мотивация*: У библиотеки должен быть четкий набор «интерфейсных» классов. Все остальные классы должны быть скрыты от клиента.

#### 2. Закрытость (sealed) классов. ####
Все классы, для которых, на данном этапе, не предполагается создание наследников, должны быть помечены как sealed.  

*Мотивация*: Необходимо четко разделять что клиент может расширить, а что не должно расширяться за счет наследования. 

#### 3. Уровни доступа и расположение в коде. ####
Код должен распологаться по уровню доступа в классе следующим образом:
1. public static   
    a. constructor  
    b. readonly fields      
    c. properties  
    d. methods  
2. public   
    a. constructor  
    b. readonly fields      
    c. properties  
    d. methods  
3. internal static     
    a. constructor  
    b. ...  
4. internal    
    a. constructor  
    b. ...  
5. protected    
    a. constructor  
    b. ...  
6. private static    
    a. constructor  
    b. properties  
    d. methods  
7. private      
    a. constructor  
    b. properties  
    d. methods  
    c. static/nonstatic readonly/nonreadonly fields.  (т.к. приватные поля вообще не должны ни кого интересовать).
    
*Мотивация*: Чем более открыта конструкция "внешниму" миру, тем раньше она должна возникать по тексту в коде. 
*Пример*
```C#
// !!! Bad !!!
class Persone
{
        private readonly Date _dateOfBirth;
        private readonly string _firstNamename;
        private string _lastName;
        //...
        public Address Position{get;set;}
        public string FirstName{get{return _firstName;}}
        public string LastName{get{return _lastName;} set{_lastName= value;}}
        
        public Person(Date dateOfBirth, string firs...)
        {
                ...
        }
        
        private string FormFullInfo()
        {
                ....
        }
        
        public override string ToString()
        {
                ....
        }
        
}

//----------------------------------------------------------------------
// GOOD:
class Persone
{        
        public Person(Date dateOfBirth, string firs...)
        {
                ...
        }
        
        
        public Address Position{get;set;}
        public string FirstName{get{return _firstName;}}
        public string LastName{get{return _lastName;} set{_lastName= value;}}


        public override string ToString()
        {
                ....
        }

        
        private string FormFullInfo()
        {
                ....
        }
        
                
        private readonly Date _dateOfBirth;
        private readonly string _firstNamename;
        private string _lastName;
        //...        
}
```


#### 4. "Только для чтения" ####
Если стоит выбор между созданием открытого свойства "только для чтения" и созданием откытого поля "только для чтения", то выбор делается на основе ответа на вопрос "Есть ли дополнительная логика при доступе к данным?". Если дополнительной логики нет - надо создавать **открытое поле "только для чтения"**, иначе - свойство. Отсюда сразу обратное правило: Открытыми могут быть **только** readonly/const поля.

*Мотивация*: Доступ к открытому полю всегда быстрее чем работа со свойством.  

*Пример*
```C#
// BAD
class Person
{
        public string FirstName{get;}        
        public string LastName{get{return _lastName}}        
        //....
        
        private readonly string _lastName;
}

//GOOD
class Person
{
        public readonly string FirstName; 
        public readonly string LastName;
        //....
}

//GOOD
class Catalog
{
        public IReadOnly<Item> Items => _items.AsReadOnly();        
        //....
}
```

#### 5. Struct vs Class ####
Надо четко понимать, структуры были созданы лишь для оптимизации работы с памятью. Отсюда, надо отдавать им предпочтение, если выполняются условия:  
* Данные не будут изменятся за время жизни "объекта"   
* Объем "полезных" данных близок к 16 байтам  
* Нет частого копирования   

Если вышеуказанные условия выполнены, то дополнительным плюсом будут такие требования:  
* Данные должны храниться близко в памяти (желательно большая часть помещаться в кэш процессора)    
* Данные должны максимально просто удаляться и быстро удаляться (т.е. желательно отчисткой стека, а не работой GC).    

При этом, структура должна быть *полностью readonly*: Сама структура и все ее **поля** должны быть readonly. Такого типа структуры не подразумивают наличие свойств, методов, рализации интерфейсов и т.д.  

*Мотивация*: Оптимизация производительности и работы с памятью.

#### 6. Релазиации интерфейсов. ####
При реализации интерфейсов в классах, необходимо делать явную (explicit) реализацию. 

*Мотивация*: Явная реализация интерфейса способствует чтобы клинет не использовал класс напрямую.   
*Ремарка*: Если некоторый метод, реализующий интерфейс, используется в других метода самого класса, то имеет смысл сделать его приватную/защещенную реализацию, и во всех интерфейсных использовать именно ее.

#### 7. IDisposable. ####
a. Если нет неуправляемх ресурсов **НЕ создавать** финализатора.  
b. Если класс помечен как sealed, и именно он реализует IDisposable, реализовывать интерфейс напрямую.

*Мотивация*: оптимизация работы GC.

## Общие заметки по коду ###
#### 1. Readonly коллекции. ####
Если предпологается возвращать (или получать на вход) ограниченной коллекции только для чтения, то в качестве результата надо возвращать (или принимать как аргумент) именно коллекции отнаследованные от IReadOnlyCollection<>.

*Мотивация*: Такой код четко говорит, что возвращается неизменяемая коллекция. Т.е. не изменяется ни ее длинна, ни ее элементы (надо понимать, что состояние отдельного элемента можно изменить, через его методы и свойства). Если же речь о входном параметре, то код говорит что данные не будут изменены. 

#### 2. Работа с IEnumerable<>. ####
Существует два варианта:

1. Как возвращаемый результат, IEnumerable<> стоит использовать, только в том случае, если метод является либо отложенным вычислением, либо генератором. В противном случае, лучше возвращать более конкретные коллекции.
*Пример*:
```C#
//BAD
IEnumerable<int> CreateRange(int len, int defVal)
{
        var result = new int[len];
        for(int i =0; i < len; ++i) 
	{
		result[i] = defVal;
	}
		
	return result;
}

//GOOD 
int[] CreateRange(int len, int defVal) // or IReadOnlyCollection<int> - если хотим вернуть неизменяемую.
{
        var result = new int[len];
        for(int i =0; i < len; ++i) 
	{
		result[i] = defVal;
	}
	
	return result;
}


//GOOD (для примера)
IEnumerable<int> FilterOnlyOdd(IEnumerable<int> source)
{
	foreach(var itr in source)
	{
        	if(itr % 2 != 0) 
	    	{
			yield  return itr;
		}
        }
}
```  

2. Если IEnumerable<> приходит в качестве аргумента, если метод **НЕ** явялется "отложенным" вычеслением над входным аргументом, то он **НЕ** должен принимать IEnumerable<>, но если все-таки приходится, то необходимо первым шагом сделать терминирующую операцию над коллекцией, с ограничением на допустимое колличество элементов. 
*Пример*:
```
//BAD 
int CountOnlyOdd(IEnumerable<int> source)
{
	long count = 0;
	foreach(var itr in source)
	{
        	if(itr % 2 != 0) 
	    	{
			count++;
		}
        }
	
	return count;
}

//GOOD 
int CountOnlyOdd(IEnumerable<int> source) //WARN: лучше принимать на вход ограниченную коллекцию.
{
	var bufSource = source.Take(Int32.Max); //WARN: должно быть разумное ограничение.
	int count = 0;
	foreach(var itr in bufSource)
	{
        	if(itr % 2 != 0) 
	    	{
			count++;
		}
        }
	
	return count;
}

```
*Мотивация*:   
	1. IEnumerable<> - это отложенное вычисление  
	2. Нет гарантии что IEnumerable<> это ограниченная коллекция
	
#### 3. Логическое "Не". ####
Если вы if надо проверить на логическое нет, то надо писать это на прямую.  
*Пример*:
```C#
//BAD
if(!string.IsNullOrEmpty(str))
{
	///...
}

//GOOD
if(string.IsNullOrEmpty(str) != true)
{
	///...
}
```
*Мотивация*: При больших конструкциях можно легко упустить отриацие "!" из виду, и ошибочно понять код, в то время как конструкцию ` != true` читается очень четко.

#### 4. Точки возврата. ####
Допускаются множественный вовзрат из функции.

#### 5. Смешивание async / sycn. ####
Стараться не смешивать асинхронный и синхронный код. 
Если же приходится использовать конструкцию `var x = someTask.ConfigureAwait(false).GetAwaiter().GetResult();`


